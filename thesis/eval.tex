%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Evaluation}

G.E.R.T is evaluated in conditions that are representative of embedded workloads.
The first few tests are benchmarks which measure G.E.R.T's maximum interrupt
frequency and pin toggle rate. The last two tests are each case studies: a robot
sensor platform and a scanning-mirror galvanometer laser projector. The test SOC
is the Freescale i.MX6Quad. Depending on the test, it is either running assembly,
GERT, or Debian 8 "Jessie" with hardfloat support. A Teensy 3.2 is used for comparison
on a few of the latency tests because of its Cortex M4 processor. All timing
measurements are taken using a Rigol DS1054Z oscilloscope.

\section{Pin Toggle Frequency}
This test measures the raw speed at which G.E.R.T can toggle a simple GPIO pin on
the iMX6 Quad SOC. In ARM assembly, this can be implemented in 4 lines. Higher pin
toggling frequency represents more efficient code. In realistic workloads, GPIO pins
would not be switched at more than a few kilohertz because there are usually dedicated
peripherals for servicing complicated protocols, but the data is still an informative
benchmark. Results are shown below in figure \ref{fig:toggle}. If PWM is desired,
G.E.R.T can produce a true PWM signal by using its PWM peripheral, as shown
in the robot sensor platform case study. \\

As expected, assembly is much faster than any of the other platforms. Additionally,
it is no surprise that GERT outperforms Go running in userspace Linux. It is not obvious
why GERT is slower than userspace C code though. An inspection of the GERT bytecode
yields the answer. To toggle a single GPIO pin in GERT, while using the embedded package,
takes 47 instructions. Of these 47 instructions, 2 are function calls, 19 are loads, and 11
are stores. This slowdown is a result of the abstractions present in the embedded package because
it models each GPIO pin as a Go interface, which comes at a cost.
When the same pin is toggled in GERT by directly manipulating the memory addresses,
instead of using the embedded library GPIO abstractions, the
frequency jumps to 500KHz. This measurement is indicated by the G.E.R.T unlayered row
in figure \ref{fig:toggle}.

\begin{figure} [h]
\begin{center}
  \begin{tabular}{ | l | l |}
    \hline
    Platform & Avg GPIO Toggle Rate \\ \hline
    ASM & 1.65MHz \\ \hline
    G.E.R.T Unlayered & 568KHz \\ \hline
    Linux C & 263KHz \\ \hline
    G.E.R.T & 154KHz \\ \hline
    Linux Go & 127 KHz \\
    \hline
  \end{tabular}
\end{center}
  \caption{GPIO Toggle Rates of Different Platforms}  \label{fig:toggle}
\end{figure}


\section{Interrupt Response Time}
This test measures the time it takes G.E.R.T to respond to an external event
with another external event. Specifically, it is the time it takes to produce
a rising edge on a GPIO pin in response to a falling edge on a different GPIO pin.
In Linux, the userspace sysfs driver exposed no methods to attach interrupts
so a polling loop was used. Results are shown below in figure \ref{fig:RT}.
GERT's advantage is due to its exposed interrupt interface. Utilizing interrupts
in Linux would have required a kernel module since the sysfs driver provided
no way to interface user-level interrupt handlers. GERT's reponse time is more
than adequate for non real-time systems and it may even be appropriate for
true real-time systems, depending on what the timing deadlines are. For
comparison, a Teensy 3.2 is included in the table because the Cortex M4
microcontroller that is has is specifically intended for embedded applications. \\


The Teensy has the fastest interrupt response time but G.E.R.T isn't far behind.
G.E.R.T is meant to run on a powerful multi-core ARMv7a with more than 1 GB of RAM but the
Cortex M4 is only single core and has less than 1MB of RAM. It is also
programmed in C.

\begin{figure} [h]
\begin{center}
  \begin{tabular}{ | l | l |}
    \hline
    Platform & Event Reponse Time \\ \hline
    Teensy 3.2 & 1$\mu$s \\ \hline
    G.E.R.T & 6.3$\mu$s \\ \hline
    Linux C & 10$\mu$s \\ \hline
    Linux Go & TBD \\
    \hline
  \end{tabular}
\end{center}
  \caption{Event Response Times of Different Platforms}  \label{fig:RT}
\end{figure}

\section{Pulse Counting}
This test measures G.E.R.T's ability to count incoming pulses. This is a very
important metric because motor encoders operate by sending out pulses to indicate
motor rotation frequency and direction. The pulses are provided by a Xilinx Artix 7
FPGA and they are variable in frequency and count. The number of pulses missed at
the limiting frequency is also recorded. In the robot sensor platform
case study below, the pulses are provided by an encoder. Results are shown in
figure \ref{fig:counter}. \\

\begin{figure} [h]
\begin{center}
  \begin{tabular}{ | l | l | l | l |}
    \hline
    Platform & Pulse Count & Max Pulse Rate & Missed Pulses \\ \hline
    Teensy 3.2 & 10 & TBD & TBD \\ \hline
    G.E.R.T & 10 & 161KHz & 1 \\ \hline
    Linux C & 10 & 161KHz & 4 \\ \hline
    Linux Go & 10 & 50KHz & 1 \\
    \hline
  \end{tabular}
\end{center}
  \caption{Pulse Counts of Different Platforms}  \label{fig:counter}
\end{figure}

\clearpage
\section{Case Study: Robot Sensor Platform}
In order to evaluate G.E.R.T on a realistic workload, I put it on a robot that was
donated to me from MIT's MASLAB competition. Among other things, the robot has two drive
motors with encoders and also Sharp GP2Y0A21YK infrared distance sensors on its perimeter.
I wrote a program in Go using G.E.R.T to interface all of these event sources at the same time
and operate the robot.

\subsection{Overview}
The main body of the program is an event loop which waits for events coming out of an event channel (fig. \ref{fig:event_loop}).
Independent goroutines monitor each sensor and send events into the event channel. There is a
single goroutine that monitors the event channel and manipulates state in a non-blocking manner. The code for the
event loop is shown below.

\begin{figure}[h]
  \begin{center}
\begin{lstlisting}
select {
	case event := <-event_chan:
		fmt.Printf("%v\n", event)
		switch event {
		case "p":
			val := adc.Read(0)
			fmt.Printf("adc reads %v\n", val)
		case "w":
			drive.Forward(0.2)
		case "s":
			drive.Backward(0.2)
		case "a":
			drive.TurnRight(0.2)
		case "d":
			drive.TurnLeft(0.2)
		case " ":
			drive.Stop()
		}
	}
\end{lstlisting}
\end{center}
  \caption{Robot Event Loop} \label{fig:event_loop}
\end{figure}

\clearpage

Golang's higher order functions and closures were also leveraged in order to create a sensor polling helper function
as shown below in fig. \ref{fig:poll_func}. In this paradigm, every sensor gets its own goroutine which sends
data back into a central event loop.

\begin{figure}[h]
\begin{center}
\begin{lstlisting}
type Pollfunc func() interface{}

func Poll(f Pollfunc, period time.Duration,
sink chan interface{}) chan bool {
	kill := make(chan bool)
	go func(kill chan bool) {
		for {
			select {
			case <-kill:
				return
			default:
				if period > 0 {
					time.Sleep(period)
				}
				sink <- f()
			}
		}
	}(kill)
	return kill
}
\end{lstlisting}
\end{center}
  \caption{Higher Order Polling Function} \label{fig:poll_func}
\end{figure}

\clearpage
The GPIO library was also configured to use interrupts in order to count pulses on the encoder (fig. \ref{fig:encoder}).

\begin{figure}[h]
\begin{center}
\begin{lstlisting}
embedded.WB_JP4_10.SetInput()
embedded.WB_JP4_10.EnableIntr(embedded.INTR_FALLING)
embedded.Enable_interrupt(99, 0) //send GPIO1 interrupt to CPU0
.
//go:nosplit
//go:nowritebarrierec
func irq(irqnum uint32) {
	switch irqnum {
...
	case 99:
		inc()
		embedded.ClearIntr(1)
...
	}
}
.
func inc() {
	count += 1
}

\end{lstlisting}
\end{center}
  \caption{Encoder Interrupt} \label{fig:encoder}
\end{figure}


With these powerful set of abstractions, adding events or sensors into the event loop
is very simple because only a Pollfunc() must be implemented. As an added bonus, this
G.E.R.T program is automatically concurrent because the Go and G.E.R.T schedulers will
move idle cpus to any available goroutine. The rest of this case study explains how the sensors
are interfaced with GERT.

\subsection{PWM Motor Control}
The robot has an MDD10A motor speed controller for controlling the two drive motors. This device
expects a pulse-width modulated signal (PWM) on its input pins in order to direct power into the
motors. A PWM signal has a constant period but the signal is a logical "on" for part of the time
and "off" for the rest of the time. The ratio of "on" time vs the period is called the duty cycle.
It is this percentage which the motor controller translates into a speed for the motor.\\

The iMX6Q includes an on-board PWM peripheral which can output several channels of PWM
at a variety of periods and duty cycles. G.E.R.T contains a driver for this in its embedded
package. The PWM peripheral requires no maintenance once it is configured so the cost of outputting
a PWM signal is essentially a few loads and stores every time the user changes the period or duty cycle.

\subsection{Distance Sensor Reading}
The Sharp distance sensor outputs an analog voltage proportional to its distance from the nearest object (fig \ref{fig:curve}).
A Microchip MCP3008 8-channel ADC is used to convert this into a digital signal. The MCP3008 only communicates in clocked
serial (SPI) though, with 24bit data frames. Luckily, the iMX6Q also has an SPI peripheral. Much like the
PWM peripheral, it has multiple channels that can each concurrently send and receive data. The embedded
package also contains a driver for the ECSPI peripheral and it works much the same way the PWM driver - 
requiring no input from the user other than the data to transmit and the length of the expected response.

\begin{figure}[h]
\begin{center}
  \includegraphics[scale=0.5]{IRSensor-3}
\end{center}
  \caption{Sharp Sensor Distance Curve} \label{fig:curve}
\end{figure}

\clearpage
\subsection{Encoder Reading}
Encoders emit a pulse every time the motor rotates a known amount. This amount is variable depending on the
encoder resolution. The encoders on the test motors emit pulses at a max rate of 4KHz, corresponding to
maximum motor speed. G.E.R.T had no difficulty picking up these pulses because this frequency is far less than
the max pulse frequency in the benchmarks above. A speed monitor was written in fig. \ref{fig:speedmon}
to measure the motor rotation (in Hz) and it corresponded very closely to the oscilliscope readings.

\begin{figure}[h]
\begin{center}
\begin{lstlisting}
//count is updated by the interrupt routine
//and it is the amount of encoder pulses
go func() {
  for {
    old := count
    time.Sleep(1 * time.Second)
    new := count
    event_chan <- new - old
  }
}()
\end{lstlisting}
\end{center}
  \caption{Motor Speed Monitor} \label{fig:speedmon}
\end{figure}

\subsection{Complications}
Systems do not work perfectly, and this robot is no exception. The switching motor controller used
on this robot emits a lot of noise. The 5v noise spikes measured on the oscilloscope wreaked havoc
on the 3.3v single-ended signals that the iMX6 operates with, causing serial communication failures
and spurious interrupts. To deal with this, the motor is operated from a dedicated power supply
when taking encoder measurements. Consequently, the physical robot cannot move when the motors
are connected to an external power supply.

\subsection{Result}
G.E.R.T is a plausible embedded toolkit to use for robots that incorporate many sensor systems.
By utilizing Go's language features, an embedded firmware engineer can implement a complicated sensor integration
platform on top of GERT without worrying about issues like scheduling or shared memory. Go's runtime manages all
of that headache and goroutines also allow for the program to scale with the number of available cpus.


\section{Case Study: Laser Projector}
A scanning-mirror galvanometer laser projector is a device that deflects a laser beam off of several mirrors in
order to draw an image on another surface. If the entire image can be scanned faster than 24Hz, then the light appears
to blend and the human brain perceives it as a single image rather than many points. The maximum rate at which the
projector can trace points is bounded below by the speed of the galvos and bounded above by the speed of the software.
I haven't written the rest of this yet so you will have to use your imagination from here.
